// This Arduino sketch was automatically generated by IrScrutinizer,
// using the export format Arduino-IRremote-Raw, version 2025-02-04.

// It supports IRremote https://github.com/Arduino-IRremote version 4.
// Earlier versions are not supported.

// For problems, bugs, and suggestions, please open an issue at
// https://github.com/bengtmartensson/IrScrutinizer/issues

/////////////////////////////////////////////////////
#include <Arduino.h>

#if !defined(ARDUINO_ESP32C3_DEV) // This is due to a bug in RISC-V compiler, which requires unused function sections :-(.
#define DISABLE_CODE_FOR_RECEIVER // Disables static receiver code like receive timer ISR handler and static IRReceiver and irparams data. Saves 450 bytes program memory and 269 bytes RAM if receiving functions are not required.
#endif

// -=-=- IR SETUP -=-=-
// #define IR_RECEIVE_PIN 1   // D1
#define IR_TX_PIN 44     // D44
#define TONE_PIN 27        // D27 25 & 26 are DAC0 and 1
#define APPLICATION_PIN 16 // RX2 pin

#define PIN_LED 21
#define NUM_LEDS 1

#define SEND_PWM_BY_TIMER // Disable carrier PWM generation in software and use (restricted) hardware PWM.
// #define USE_NO_SEND_PWM           // Use no carrier PWM, just simulate an active low receiver signal. Overrides SEND_PWM_BY_TIMER definition
// #define NO_LED_FEEDBACK_CODE      // Saves 566 bytes program memory
// #define USE_OPEN_DRAIN_OUTPUT_FOR_SEND_PIN // Use or simulate open drain output mode at send pin. Attention, active state of open drain is LOW, so connect the send LED between positive supply and send pin!

#include <IRremote.hpp>

#include <M5Cardputer.h>
#include <FastLED.h>

CRGB leds[NUM_LEDS];
uint8_t led_ih = 0;
uint8_t led_status = 0;
String led_status_string[] = {"Rainbow", "Red", "Green", "Blue"};

// This sketch uses the PROGMEM mechanism to put constant data into flash memory
// as opposed to RAM memory. An "Arduino" board typically has quite small RAM
// memory and "a lot" of flash memory, and the PROGMEM feature locates large
// static dato to flash memory. In order not to use the PROGMEM feature,
// uncomment the following two lines:
// #define PROGMEM /* nothing */
// #define sendRaw_P sendRaw
// Static data for the commands
static unsigned int no_sends = 1U;

void setup()
{
  auto cfg = M5.config();
  M5Cardputer.begin(cfg);
  M5Cardputer.Lcd.begin();
  FastLED.addLeds<WS2812, PIN_LED, GRB>(leds, NUM_LEDS);

  IrSender.begin(DISABLE_LED_FEEDBACK);
  IrSender.setSendPin(IR_TX_PIN);

  M5Cardputer.Display.setTextSize(2.f);
  M5Cardputer.Display.println("Enter command");
}

constexpr size_t kNameLen = 16;
struct CodeInfo
{
  char Key;
  uint16_t Code;
  char Name[kNameLen];
};

constexpr size_t NumCodes = 8;
CodeInfo g_Codes[NumCodes] = 
{
  {'1', 26U, "HDMI1 "},
  {'2', 1U,  "HDMI2 "},
  {'3', 2U,  "HDMI3 "},
  {'4', 3U,  "HDMI4 "},
  {'5', 5U,  "HDMI5 "},
  {'6', 12U, "2.0 ch"},
  {'7', 13U, "5.1 ch"},
  {'8', 14U, "TV ch "},
};

void loop()
{
  M5Cardputer.update();

  for (size_t i=0; i<NumCodes; ++i)
  {
    if (M5Cardputer.Keyboard.isKeyPressed(g_Codes[i].Key))
    {
      M5Cardputer.Display.setCursor(0, 20);
      M5Cardputer.Display.printf("Key: %c\n", g_Codes[i].Key);
      M5Cardputer.Display.printf("Command: %s\n", g_Codes[i].Name);

      leds[0] = CRGB::Red;
      FastLED.show();

      IrSender.sendNEC(128U | (126U << 8), g_Codes[i].Code, no_sends - 1);
      delay(1000);
    }
  }

  int commandno = -1;
  for (char key='0'; key<='9'; ++key)
  {
    if (M5Cardputer.Keyboard.isKeyPressed(key))
    {
      M5Cardputer.Display.setCursor(0, 20);
      M5Cardputer.Display.printf("Key: %c\n", key);
      commandno = key - (int)'0';
      break;
    }
  }

  leds[0] = CRGB::Blue;
  FastLED.show();
}
